# -*- coding: utf-8 -*-
"""Validation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18w-ahbLBjiN75H50qnJU4HbojearHBzU
"""

import tensorflow as tf
from tensorflow.keras.models import load_model
import numpy as np
import matplotlib.pyplot as plt



import xarray as xr 
xf=xr.open_dataset("/content/drive/My Drive/files_val_july.nc")

data=xf["IMG_TIR1"].values
xf.close()

def scaleData(a):       
    return (a-np.nanmin(a))/(np.nanmax(a)-np.nanmin(a))

def prepare_data(data):
    tdata=[]
    tlabels=[]
    img_size=(404,404)
    print(len(data))
    arrdata=np.ones((len(data)-6,6,img_size[0],img_size[1],1))
    arrlabel=np.ones((len(data)-6,6,img_size[0],img_size[1],1))
    
    for i in range(0,len(data)-6-5,1):
        m=0
        for j in range(i,i+6,1):

            arrdata[i,m,:,:,0]=data[j]
            arrlabel[i,m,:,:,0]=data[j+6] 

            m+=1
        # print(i,j,j+1,j+6)

    print(arrdata.shape)
    print(arrlabel.shape)
    return arrdata,arrlabel

new=[]
for i in data:
    value=scaleData(i)
    new.append(value)

data,label=prepare_data(new)

fig,ax=plt.subplots(2,6,figsize=(18,8),subplot_kw={'xticks':[], 'yticks':[]})

var=0
for i in range(6):
      ax[0,i].imshow(data[var,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[1,i].imshow(label[var,i,:,:,0],cmap="gray",vmin=0,vmax=1)

def predict(x, encoder_predict_model, decoder_predict_model, num_steps_to_predict):
  
    y_predicted = []
    
    state_h,state_c = encoder_predict_model.predict(x)
    states=[state_h,state_c]    
    decoder_input = np.zeros((1,1,404,404,1))
    decoder_input[0,0,:,:,0]=x[0,-1,:,:,0]
    
    for _ in range(num_steps_to_predict):
        outputs_and_states = decoder_predict_model.predict([decoder_input] + states)
      
        output = outputs_and_states[0]
      
        states= outputs_and_states[1:]
       

        # add predicted value
        output=scaleData(output)
        decoder_input=output

        y_predicted.append(output)
    return np.concatenate(y_predicted, axis=1)

def predict_(x, encoder_predict_model, decoder_predict_model, num_steps_to_predict):
  
    y_predicted = []
    
    state_h,state_c = encoder_predict_model.predict(x)
    states=[state_h,state_c]    
    decoder_input = np.zeros((1,1,404,404,1))
    # decoder_input[0,0,:,:,0]=x[0,-1,:,:,0]
    
    for _ in range(num_steps_to_predict):
        outputs_and_states = decoder_predict_model.predict([decoder_input] + states)
      
        output = outputs_and_states[0]
      
        states= outputs_and_states[1:]
       
        # add predicted value
        output=scaleData(output)
        decoder_input=output

        y_predicted.append(output)
    return np.concatenate(y_predicted, axis=1)

Encoder_model=load_model("Encoder.h5")
Decoder_model=load_model("Decoder.h5")
Forecaster_model=load_model("Forecaster.h5")

ans= predict( data[0:1], Encoder_model, Forecaster_model, 12)

ans1= predict_( data[0:1], Encoder_model, Decoder_model, 6)
ans1[:,:,:,:,:]=ans1[:,::-1,:,:,:]

fig,ax=plt.subplots(4,6,figsize=(18,12),subplot_kw={'xticks':[], 'yticks':[]})

for i in range(6):
      ax[0,i].imshow(data[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[1,i].imshow(ans1[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[2,i].imshow(label[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[3,i].imshow(ans[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)

fig,ax=plt.subplots(4,6,figsize=(18,12),subplot_kw={'xticks':[], 'yticks':[]})

for i in range(6):
      ax[0,i].imshow(data[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      # ax[1,i].imshow(ans1[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[1,i].imshow(label[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[2,i].imshow(ans[0,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[3,i].imshow(ans[0,i,:,:,0]-label[0,i,:,:,0],cmap="gray",vmin=-1,vmax=1)

rm -f *.png

from PIL import Image
for i in range(12):
  
  print(np.nanmax(ans[0,i,:,:,0]),np.nanmin(ans[0,i,:,:,0]))
  plt.imsave("TIR1_"+str(i)+".png",arr=ans[0,i,:,:,0],cmap="gray")

l=np.zeros((len(data),6,404,404,1))
for i in range(len(data)):
   ans= predict(data[np.newaxis,i], Encoder_model, Forecaster_model, 6)
   l[i]=ans[0]
   print(i)

fig,ax=plt.subplots(2,6,figsize=(18,12),subplot_kw={'xticks':[], 'yticks':[]})

for i in range(6):
      ax[0,i].imshow(l[-1,i,:,:,0],cmap="gray",vmin=0,vmax=1)
      ax[1,i].imshow(label[24,i,:,:,0],cmap="gray",vmin=0,vmax=1)



import math as m
def get_corr(a,b):
    a1=a.reshape((-1))
    b1=b.reshape((-1))
    # a2=np.sum(a1*b1)/(m.sqrt( np.sum(a1**2)*np.sum(b1**2)+10**-9) )
    a2=np.corrcoef(a1,b1)[1,0]
    return a2

cnl_0,cnl_1,cnl_2,cnl_3,cnl_4,cnl_5=[],[],[],[],[],[]
for i in range(89):
    cnl0=get_corr(l[i][0,:,:,0],label[i,0,:,:,0])
    cnl1=get_corr(l[i][1,:,:,0],label[i,1,:,:,0])
    cnl2=get_corr(l[i][2,:,:,0],label[i,2,:,:,0])
    cnl3=get_corr(l[i][3,:,:,0],label[i,3,:,:,0])
    cnl4=get_corr(l[i][4,:,:,0],label[i,4,:,:,0])
    cnl5=get_corr(l[i][5,:,:,0],label[i,5,:,:,0])

    cnl_0.append(cnl0)
    cnl_1.append(cnl1)
    cnl_2.append(cnl2)
    cnl_3.append(cnl3)
    cnl_4.append(cnl4)
    cnl_5.append(cnl5)
    
Z=[i for i in cnl_0 ]
N=[i for i in cnl_1 ]
B=[i for i in cnl_2 ]
V=[i for i in cnl_3 ]
G=[i for i in cnl_4 ]
H=[i for i in cnl_5 ]
print(np.nanmean(Z))
print(np.nanmean(N))
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

import seaborn as sns

bin=np.arange(0,1000,20)             
             
sns.distplot(Z, hist=False, kde=True, 
             bins = bin, color = 'red',label = '1',
             kde_kws={'linewidth': 4})

sns.distplot(N, hist=False, kde=True, 
             bins = bin, color = 'green',label = '2', 
             kde_kws={'linewidth': 4})

sns.distplot(B, hist=False, kde=True, 
             bins = bin, color = 'blue',label = '3',
             kde_kws={'linewidth': 4})
             
sns.distplot(V, hist=False, kde=True, 
             bins = bin, color = 'black',label = '4',
             kde_kws={'linewidth': 4})

sns.distplot(G, hist=False, kde=True, 
             bins = bin, color = 'purple',label = '5',
             kde_kws={'linewidth': 4})

sns.distplot(H, hist=False, kde=True, 
             bins = bin, color = 'orange',label = '6',
             kde_kws={'linewidth': 4})

plt.savefig('corr.png',dpi=400,format='png')

from sklearn.metrics import mean_squared_error
def get_mse(x, y):
    return mean_squared_error(x,y)
    # return np.linalg.norm(x - y)

cnl_0,cnl_1,cnl_2,cnl_3,cnl_4,cnl_5=[],[],[],[],[],[]
for i in range(89):
    cnl0=get_mse(l[i][0,:,:,0],label[i,0,:,:,0])
    cnl1=get_mse(l[i][1,:,:,0],label[i,1,:,:,0])
    cnl2=get_mse(l[i][2,:,:,0],label[i,2,:,:,0])
    cnl3=get_mse(l[i][3,:,:,0],label[i,3,:,:,0])
    cnl4=get_mse(l[i][4,:,:,0],label[i,4,:,:,0])
    cnl5=get_mse(l[i][5,:,:,0],label[i,5,:,:,0])   


    cnl_0.append(cnl0)
    cnl_1.append(cnl1)
    cnl_2.append(cnl2)
    cnl_3.append(cnl3)
    cnl_4.append(cnl4)
    cnl_5.append(cnl5) 
print(np.nanmean(cnl_0))
print(np.nanmean(cnl_1))
print(np.nanmean(cnl_2))
print(np.nanmean(cnl_3))
print(np.nanmean(cnl_4))
print(np.nanmean(cnl_5))

bin=np.arange(0,1000,20)             
             
sns.distplot(cnl_0, hist=False, kde=True, 
             bins = bin, color = 'red',label = '1',
             kde_kws={'linewidth': 4})

sns.distplot(cnl_1, hist=False, kde=True, 
             bins = bin, color = 'green',label = '2', 
             kde_kws={'linewidth': 4})

sns.distplot(cnl_2, hist=False, kde=True, 
             bins = bin, color = 'blue',label = '3',
             kde_kws={'linewidth': 4})
             
sns.distplot(cnl_3, hist=False, kde=True, 
             bins = bin, color = 'black',label = '4',
             kde_kws={'linewidth': 4})

sns.distplot(cnl_4, hist=False, kde=True, 
             bins = bin, color = 'purple',label = '5',
             kde_kws={'linewidth': 4})

sns.distplot(cnl_5, hist=False, kde=True, 
             bins = bin, color = 'orange',label = '6',
             kde_kws={'linewidth': 4})

def get_metric(xx,yy) :
  t=0.5
  b=np.zeros((404,404))
  c=np.zeros((404,404))
  b=np.where(xx > t,1,b)
  c=np.where(yy > t,1,c)
  h,t,f,m=0,0,0,0
  # plt.imshow(b-c,cmap="gray")
  # plt.colorbar()
  # plt.show()
  for p in range(404):
    for q in range(404):
        if(b[p,q]==1 and c[p,q]==1):
          h+=1
        if(b[p,q]==0 and c[p,q]==0):
          t+=1
        if(b[p,q]==1 and c[p,q]==0):
          f+=1
        if(b[p,q]==0 and c[p,q]==1):
          m+=1

  csi=h/(h+m+f)
  far=f/(h+f)
  pod=h/(h+m)
  acc=(h+t)/(h+m+f+t)
  print(csi,far,pod,acc)
  return csi,far,pod,acc

cnl_0,cnl_1,cnl_2,cnl_3,cnl_4,cnl_5=[],[],[],[],[],[]
for i in range(89):
    cnl0=get_metric(l[i][0,:,:,0],label[i,0,:,:,0])
    cnl1=get_metric(l[i][1,:,:,0],label[i,1,:,:,0])
    cnl2=get_metric(l[i][2,:,:,0],label[i,2,:,:,0])
    cnl3=get_metric(l[i][3,:,:,0],label[i,3,:,:,0])
    cnl4=get_metric(l[i][4,:,:,0],label[i,4,:,:,0])
    cnl5=get_metric(l[i][5,:,:,0],label[i,5,:,:,0])   


    cnl_0.append(cnl0)
    cnl_1.append(cnl1)
    cnl_2.append(cnl2)
    cnl_3.append(cnl3)
    cnl_4.append(cnl4)
    cnl_5.append(cnl5)

Z=[i[0] for i in cnl_0 ]
N=[i[0] for i in cnl_1]
B=[i[0] for i in cnl_2]
V=[i[0] for i in cnl_3]
G=[i[0] for i in cnl_4]
H=[i[0] for i in cnl_5]


print(np.nanmean(Z))
print(np.nanmean(N))
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

Z=[i[1] for i in cnl_0 ]
N=[i[1] for i in cnl_1]
B=[i[1] for i in cnl_2]
V=[i[1] for i in cnl_3]
G=[i[1] for i in cnl_4]
H=[i[1] for i in cnl_5]


print(np.nanmean(Z))
print(np.nanmean(N))
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

Z=[i[2] for i in cnl_0 ]
N=[i[2] for i in cnl_1]
B=[i[2] for i in cnl_2]
V=[i[2] for i in cnl_3]
G=[i[2] for i in cnl_4]
H=[i[2] for i in cnl_5]


print(np.nanmean(Z))
print(np.nanmean(N))
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

Z=[i[-1] for i in cnl_0  ]
N=[i[-1] for i in cnl_1 ]
B=[i[-1] for i in cnl_2 ]
V=[i[-1] for i in cnl_3 ]
G=[i[-1] for i in cnl_4 ]
H=[i[-1] for i in cnl_5 ]


print(np.nanmean(Z))
print(np.nanmean(N))  
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

Z

t1=0.7
t2=0.8
h,m=0,0
b=np.zeros((404,404))
c=np.zeros((404,404))
b[:]=-1
c[:]=-1

for i in range(404):
    for j in range(404):
      if(l[0,0,i,j,0]>=t1 and l[0,0,i,j,0]<=t2):
         b[i,j]=1
      elif(l[0,0,i,j,0]>t2):
        b[i,j]=0
      elif(l[0,0,i,j,0]<t1):
        b[i,j]=0

for i in range(404):
    for j in range(404):
      if(label[0,0,i,j,0]>=t1 and label[0,0,i,j,0]<=t2):
         c[i,j]=1
      elif(label[0,0,i,j,0]>t2):
        c[i,j]=0
      elif(label[0,0,i,j,0]<t1):
        c[i,j]=0
plt.imshow(b-c)
plt.colorbar()
plt.show()

print(np.count_nonzero(b-c == 0))
print(np.count_nonzero(b-c == 1))
print(np.count_nonzero(b-c == -1))

def get_bar_graph(xx,yy):
  t1=0.0
  t2=0.25

  b=np.zeros((404,404))
  c=np.zeros((404,404))
  # b[:]=-1
  # c[:]=-1

  for i in range(404):
      for j in range(404):
        if(xx[i,j] >=t1 and xx[i,j] <=t2):
          b[i,j]=1
        elif(xx[i,j] >t2):
          b[i,j]=0
        elif(xx[i,j] <t1):
          b[i,j]=0

  for i in range(404):
      for j in range(404):
        if(yy[i,j] >=t1 and yy[i,j] <=t2):
          c[i,j]=1
        elif(yy[i,j] >t2):
          c[i,j]=0
        elif(yy[i,j] <t1):
          c[i,j]=0
  h=np.count_nonzero(b-c == 0)
  f=np.count_nonzero(b-c == 1)
  m=np.count_nonzero(b-c == -1)
  print(h,f,m,404*404)
  
  total=h+f+m
  h=h/total
  f=f/total
  m=m/total
  print(h,f,m)
  return h*100,f*100,m*100

cnl_0,cnl_1,cnl_2,cnl_3,cnl_4,cnl_5=[],[],[],[],[],[]
for i in range(89):
    cnl0=get_bar_graph(l[i][0,:,:,0],label[i,0,:,:,0])
    cnl1=get_bar_graph(l[i][1,:,:,0],label[i,1,:,:,0])
    cnl2=get_bar_graph(l[i][2,:,:,0],label[i,2,:,:,0])
    cnl3=get_bar_graph(l[i][3,:,:,0],label[i,3,:,:,0])
    cnl4=get_bar_graph(l[i][4,:,:,0],label[i,4,:,:,0])
    cnl5=get_bar_graph(l[i][5,:,:,0],label[i,5,:,:,0])   


    cnl_0.append(cnl0)
    cnl_1.append(cnl1)
    cnl_2.append(cnl2)
    cnl_3.append(cnl3)
    cnl_4.append(cnl4)
    cnl_5.append(cnl5)

Z=[i[1] for i in cnl_0 ]
N=[i[1] for i in cnl_1]
B=[i[1] for i in cnl_2]
V=[i[1] for i in cnl_3]
G=[i[1] for i in cnl_4]
H=[i[1] for i in cnl_5]


print(np.nanmean(Z))
print(np.nanmean(N))
print(np.nanmean(B))
print(np.nanmean(V))
print(np.nanmean(G))
print(np.nanmean(H))

hist_data=np.zeros((3,6))

for m in range(3):
  Z=[i[m] for i in cnl_0 ]
  N=[i[m] for i in cnl_1]
  B=[i[m] for i in cnl_2]
  V=[i[m] for i in cnl_3]
  G=[i[m] for i in cnl_4]
  H=[i[m] for i in cnl_5]
  # print(np.nanmean(Z)))

  hist_data[m,0]=np.nanmean(Z)
  hist_data[m,1]=np.nanmean(N)
  hist_data[m,2]=np.nanmean(B)
  hist_data[m,3]=np.nanmean(V)
  hist_data[m,4]=np.nanmean(G)
  hist_data[m,5]=np.nanmean(H)

hist_data[0]

import numpy as np
import matplotlib.pyplot as plt
# data = hist_data
# X = np.arange(6)
# fig, ax = plt.subplots()
t1=0.0
t2=0.25
# ax.bar(X + 0.00, data[0], color = 'b', width = 0.25)
# ax.bar(X + 0.25, data[1], color = 'g', width = 0.25)
# ax.bar(X + 0.50, data[2], color = 'r', width = 0.25)

n_groups = 6
mean_hits = hist_data[0]
mean_false =hist_data[1]
mean_miss=hist_data[2]

# create plot
fig, ax = plt.subplots(figsize=(10,8))
index = np.arange(n_groups)
bar_width = 0.25
opacity = 0.8

rects1 = plt.bar(index, mean_hits, bar_width,
alpha=opacity,
color='b',
label='Hits')

rects2 = plt.bar(index + bar_width, mean_false, bar_width,
alpha=opacity,
color='g',
label='False values')


rects3 = plt.bar(index + bar_width+bar_width, mean_miss, bar_width,
alpha=opacity,
color='r',
label='Miss')

# plt.ylim([100,100000])
plt.xlabel('Prediction Frame',fontsize=18)
plt.ylabel('Percentage ( % )',fontsize=18 )

plt.title('Relative Operating Characteristic Bar Plot',fontsize=18)
plt.xticks(index+bar_width,('T(n+1)', 'T(n+2)', 'T(n+3)', 'T(n+4)','T(n+5)','T(n+6)'))
plt.legend()
ax=plt.gca()

ax.set_facecolor((0.73,0.73,0.73))
ax.tick_params(labelsize='x-large')
plt.tight_layout()
# plt.savefig('barplot_0.3_0.6.png',dpi=400,format='png')
plt.savefig('barplot_'+str(t1)+'_'+str(t2)+'.png',dpi=400,format='png',figsize=(5,9))
plt.show()



